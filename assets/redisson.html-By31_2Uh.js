import{_ as s,c as r,e,b as n,a as i,r as d,o as a}from"./app-DxtTthfZ.js";const c={},l={class:"mermaid-medium"};function g(h,t){const o=d("Mermaid");return a(),r("div",null,[t[0]||(t[0]=e('<h2 id="redis-延迟队列与redisson实现" tabindex="-1"><a class="header-anchor" href="#redis-延迟队列与redisson实现"><span>Redis 延迟队列与redisson实现</span></a></h2><h3 id="_1-核心架构组件" tabindex="-1"><a class="header-anchor" href="#_1-核心架构组件"><span>1. 核心架构组件</span></a></h3><p>Redisson 实现延迟队列并非只用了一个 Key，而是通过 <strong>“三位一体”</strong> 的结构来平衡性能与可靠性：</p><ul><li><strong><code>zset</code> (timeout_set)</strong>：<strong>任务仓库</strong>。按到期时间戳（Score）排序存放所有未到期的任务。</li><li><strong><code>list</code> (blocking_queue)</strong>：<strong>就绪队列</strong>。仅存放“已经到期”的任务，供业务逻辑通过 <code>take()</code> 消费。</li><li><strong><code>channel</code> (pubsub_channel)</strong>：<strong>调度中心</strong>。用于在分布式节点间同步“最早到期时间”的信号。</li></ul><hr><h3 id="_2-核心机制-现实问题-vs-解决方案" tabindex="-1"><a class="header-anchor" href="#_2-核心机制-现实问题-vs-解决方案"><span>2. 核心机制：现实问题 vs 解决方案</span></a></h3><table><thead><tr><th>现实中的工程难题</th><th>Redisson 的应对方案</th><th>设计巧妙之处</th></tr></thead><tbody><tr><td><strong>轮询开销</strong></td><td><strong>HashedWheelTimer (本地时间轮)</strong></td><td>客户端根据 ZSet 头部任务时间进行本地倒计时，<strong>无需高频请求 Redis</strong>。</td></tr><tr><td><strong>任务抢占竞争</strong></td><td><strong>Lua 脚本原子操作</strong></td><td>判定过期、从 ZSet 移出、推入 List 在同一个脚本完成，<strong>确保任务不被重复消费</strong>。</td></tr><tr><td><strong>新任务插队</strong></td><td><strong>Pub/Sub 实时通知</strong></td><td>当有更早的任务插入时，生产者发布信号，<strong>强制所有消费者更新本地倒计时</strong>。</td></tr><tr><td><strong>时钟漂移误差</strong></td><td><strong>参数校验与二次调度</strong></td><td>Lua 脚本根据传参比对，若因误差取不到数据则返回剩余毫秒数，客户端进行 <strong>ms 级重试</strong>。</td></tr><tr><td><strong>消费阻塞感</strong></td><td><strong>List 的 BLPOP 模式</strong></td><td>业务端直接 <code>take()</code> 阻塞，像操作普通 MQ 一样简单，屏蔽了底层的各种搬运逻辑。</td></tr></tbody></table><hr><h3 id="_3-发布订阅-pub-sub-的同步逻辑" tabindex="-1"><a class="header-anchor" href="#_3-发布订阅-pub-sub-的同步逻辑"><span>3. 发布订阅（Pub/Sub）的同步逻辑</span></a></h3><p>这是解决“实时性”的关键。当分布式环境下的多个客户端共同操作一个队列时：</p><ol><li><strong>信号源（Publisher）</strong>：当任何一个客户端 <code>offer</code> 任务且该任务排在 ZSet 第一位时，Lua 脚本发出 <code>PUBLISH</code> 信号。</li><li><strong>信号传播</strong>：Redis 服务端将信号广播给所有订阅了该队列的消费者。</li><li><strong>响应动作（Subscriber）</strong>：</li></ol><ul><li>消费者收到通知后，立即检查 ZSet 头部。</li><li>如果发现新的到期时间比当前本地定时器更早，则<strong>取消旧定时器，启动新定时器</strong>。</li><li>这确保了即使新任务只延迟 1 秒，也能被立即感知。</li></ul><hr><h3 id="_4-架构交互流程图" tabindex="-1"><a class="header-anchor" href="#_4-架构交互流程图"><span>4. 架构交互流程图</span></a></h3>',14)),n("div",l,[i(o,{id:"mermaid-148",code:"eJxlkl9P2lAYxu/5FG+8ggRq9n/rBYmWC5eQpcEtS7w7kZPRDNHRumsGc6KbjqEOpx2ExAkmKt1GEGiWfpm+h/Zb7LRn2XD28vT3Pu/zPOfo9NU6LSzTlEZeFMlKBPi3RoqGtqytkYIBKhAdJvstd9zxShsQVfIa5cdzsRtkJiAzNKvpEF1apMZsWtONWSVHCgWav4krAc4GVa8/mhaej0VC9MmqQWH1NS2CGoeMDK5t43YbP37CYSUE1EQyyc9vScC2Ol77A6TXiQxLc6kUYNViZos1Bn6jz6o/QzyT4Lwqw20J8LTMmiY77LHPFixQkqXFOHBlv/QG1Gfz6ceLC+A6fNfVv0lFhjt8cuSw+oX4J8MMM0uscSb24NUPdtznijP/+1dC/55VwfGpO9wVkUNGERHuSuB1ythrQVAb4Enfr3Rx68z99UVo/4W5i3vcRa2H211mnqPJ/RM9R7PPc5Tmn2orfB2W6t5lmw9Or7gvgd8Y+fUW7u2443fxa52h9dXrHbDauefUPGeTVyfK/pM+FHggCXOTjo2bY0gkge12ceMbBJd8raaHPI2zj8dNITix93jZ0wkecS+HNrabaHbDcZgcvQWDvKTRGLCLE26dvXeCOzyw2M4ljgZCzx0eBS/gezkS+Q2mUDYd"})]),t[1]||(t[1]=e('<hr><h3 id="_5-异常场景处理总结" tabindex="-1"><a class="header-anchor" href="#_5-异常场景处理总结"><span>5. 异常场景处理总结</span></a></h3><ul><li><strong>如果消费者挂了</strong>：任务会一直留在 ZSet 中。当任何一个新的消费者启动时，会触发一次扫描逻辑，将 ZSet 中所有已过期的任务批量搬运到 List，实现<strong>自动补偿</strong>。</li><li><strong>如果 Redis 挂了</strong>：开启 AOF 持久化后，ZSet 和 List 都会恢复。由于逻辑都在 Lua 中，恢复后系统会自动回到正确状态。</li><li><strong>时钟不同步</strong>：系统容忍毫秒级的时钟漂移。若漂移过大，Lua 脚本会作为“裁判员”返回正确的剩余时间，修正客户端的下一次触发。</li></ul><hr>',4))])}const u=s(c,[["render",g]]),m=JSON.parse('{"path":"/posts/tech/redisson.html","title":"redis-delay-queue","lang":"zh-CN","frontmatter":{"title":"redis-delay-queue","icon":"pen-to-square","date":"2026-01-21T00:00:00.000Z","category":["tech"],"tags":["redis"],"description":"Redis 延迟队列与redisson实现 1. 核心架构组件 Redisson 实现延迟队列并非只用了一个 Key，而是通过 “三位一体” 的结构来平衡性能与可靠性： zset (timeout_set)：任务仓库。按到期时间戳（Score）排序存放所有未到期的任务。 list (blocking_queue)：就绪队列。仅存放“已经到期”的任务，供...","head":[["meta",{"property":"og:url","content":"https://rainbow-cc.github.io/MyBlog/posts/tech/redisson.html"}],["meta",{"property":"og:site_name","content":"橙子的博客"}],["meta",{"property":"og:title","content":"redis-delay-queue"}],["meta",{"property":"og:description","content":"Redis 延迟队列与redisson实现 1. 核心架构组件 Redisson 实现延迟队列并非只用了一个 Key，而是通过 “三位一体” 的结构来平衡性能与可靠性： zset (timeout_set)：任务仓库。按到期时间戳（Score）排序存放所有未到期的任务。 list (blocking_queue)：就绪队列。仅存放“已经到期”的任务，供..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-01-21T07:26:55.000Z"}],["meta",{"property":"article:tag","content":"redis"}],["meta",{"property":"article:published_time","content":"2026-01-21T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2026-01-21T07:26:55.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"redis-delay-queue\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2026-01-21T00:00:00.000Z\\",\\"dateModified\\":\\"2026-01-21T07:26:55.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Rainbow\\",\\"url\\":\\"https://rainbow-cc.github.io/MyBlog/\\"}]}"]]},"git":{"createdTime":1768980415000,"updatedTime":1768980415000,"contributors":[{"name":"Rainbow","username":"Rainbow","email":"494738974@qq.com","commits":1,"url":"https://github.com/Rainbow"}]},"readingTime":{"minutes":3.01,"words":903},"filePathRelative":"posts/tech/redisson.md","localizedDate":"2026年1月21日","excerpt":"<h2>Redis 延迟队列与redisson实现</h2>\\n<h3>1. 核心架构组件</h3>\\n<p>Redisson 实现延迟队列并非只用了一个 Key，而是通过 <strong>“三位一体”</strong> 的结构来平衡性能与可靠性：</p>\\n<ul>\\n<li><strong><code>zset</code> (timeout_set)</strong>：<strong>任务仓库</strong>。按到期时间戳（Score）排序存放所有未到期的任务。</li>\\n<li><strong><code>list</code> (blocking_queue)</strong>：<strong>就绪队列</strong>。仅存放“已经到期”的任务，供业务逻辑通过 <code>take()</code> 消费。</li>\\n<li><strong><code>channel</code> (pubsub_channel)</strong>：<strong>调度中心</strong>。用于在分布式节点间同步“最早到期时间”的信号。</li>\\n</ul>","autoDesc":true}');export{u as comp,m as data};
