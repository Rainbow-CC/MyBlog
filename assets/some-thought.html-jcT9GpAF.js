import{_ as e,c as i,e as l,o}from"./app-6zMFofFN.js";const p={};function a(n,t){return o(),i("div",null,[...t[0]||(t[0]=[l('<h1 id="关于ai" tabindex="-1"><a class="header-anchor" href="#关于ai"><span>关于AI</span></a></h1><p>最近我在思考一个问题：作为一个程序员，在AI的浪潮下，什么东西是值钱的，什么东西不再有用。</p><p>正如C语言出来之后，汇编技能价值就降低了，会娴熟地编写汇编语言，可能用处不大了，但是懂得原理是必要的。<br> 和汇编语言相比，C语言无疑是更加高效的编程语言，编译器生成的汇编代码也是完全合格的。大语言模型（LLM）在一定程度上，做了相似的事情：</p><ul><li>生成前端代码，做个网站。</li><li>独立的功能，生成一个方法或函数</li><li>指令运维指令，检查问题、安装依赖</li><li>调用MCP工具，完成更多指定操作</li><li>......</li></ul><p>对于很多工作流程来说，AI指令几乎是“高级语言”，虽然转化而来的代码或者指令，没有编译器那么固定、精确，但基本类似。古法编程变得价值越来越低。</p><p>现在想一下，假如我们要做个网站，我们和不懂行的小朋友，最大的区别是什么？我们会写代码，但是小朋友把朴素的需求告诉AI，AI实现的代码甚至比我们更加优雅。<br> 我们会做调试，能够解决报错，AI也可以，报错贴出来，解决效率甚至比自己要强很多。现在AI功能越来越傻瓜化，手机App 就能调用很多AI能力，不管是小朋友，还是退休<br> 的大爷大妈，手机上点点，玩一玩，可能也能出来不错的东西。哪怕现在不行，将来也一定会实现的，用AI能力就像用智能手机一样简单通俗。</p><p>所以我想，真正有价值的东西，在于know how：</p><p>我们到底需要做个<strong>什么东西</strong>？它不是许愿式的几个需求，动动手指搞出的Demo，而是真正的工程，我们的目标是什么，要把App或者作品做成什么样子，满足什么需求，选择什么技术路线，可能遇到什么阻碍，如何选择兜底方案，以及，开发完成之后如何修改和扩展。</p><p>举个例子，我们想做AI视频二创，可能要思考一下：</p><p><em>规划：</em></p><ul><li>这个二创的主题是什么，创作亮点是什么，受众是谁</li><li>视频长度是多少，如何编排场景</li></ul><p><em>执行：</em></p><ul><li>原视频怎么下载</li><li>用什么软件剪辑</li><li>配音如何生成，选择什么TTS工具</li><li>选用什么工具对视频进行AI二创</li><li>如何形成工作流，进行效率精进</li></ul><p>发布之后，可能还要收集反馈，思考我们的制作质量如何。<br> 很显然，制作AI视频人人会玩，但是这些东西是某些软件上动动手指进行傻瓜式操作完全无法替代的。这是根本性的价值所在。</p><p>最近我在尝试各种途径的人机协作，包括：</p><ul><li>AI PPT协作（使用Slidev，制作网页形式的PPT）</li></ul><p><em>这种形式，能够充分发挥AI的代码优势，制作精确的布局和效果，并且上限较高，可以制作PPT软件无法完成的动效</em></p><ul><li>AI 项目理解（Google CodeWiki）</li></ul><p><em>对代码库的理解非常深入，不管是学习，还是帮助自己的代码库进行迭代，都很好用</em></p><ul><li>AI 终端</li></ul><p><em>Gemini-cli， yyds！能够调用电脑上的资源，执行npm或者Shell指令等等，电脑上能用powershell终端搞定的操作，都可以切换成自然语言模式，比如给一个项目安装依赖等等</em></p>',21)])])}const m=e(p,[["render",a]]),c=JSON.parse('{"path":"/posts/chat/some-thought.html","title":"AI时代的一些思考","lang":"zh-CN","frontmatter":{"title":"AI时代的一些思考","icon":"pen-to-square","date":"2025-12-23T00:00:00.000Z","category":["杂谈"],"tag":["杂谈"],"description":"关于AI 最近我在思考一个问题：作为一个程序员，在AI的浪潮下，什么东西是值钱的，什么东西不再有用。 正如C语言出来之后，汇编技能价值就降低了，会娴熟地编写汇编语言，可能用处不大了，但是懂得原理是必要的。 和汇编语言相比，C语言无疑是更加高效的编程语言，编译器生成的汇编代码也是完全合格的。大语言模型（LLM）在一定程度上，做了相似的事情： 生成前端代码...","head":[["meta",{"property":"og:url","content":"https://rainbow-cc.github.io/MyBlog/posts/chat/some-thought.html"}],["meta",{"property":"og:site_name","content":"橙子的博客"}],["meta",{"property":"og:title","content":"AI时代的一些思考"}],["meta",{"property":"og:description","content":"关于AI 最近我在思考一个问题：作为一个程序员，在AI的浪潮下，什么东西是值钱的，什么东西不再有用。 正如C语言出来之后，汇编技能价值就降低了，会娴熟地编写汇编语言，可能用处不大了，但是懂得原理是必要的。 和汇编语言相比，C语言无疑是更加高效的编程语言，编译器生成的汇编代码也是完全合格的。大语言模型（LLM）在一定程度上，做了相似的事情： 生成前端代码..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-01-11T15:56:45.000Z"}],["meta",{"property":"article:tag","content":"杂谈"}],["meta",{"property":"article:published_time","content":"2025-12-23T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2026-01-11T15:56:45.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"AI时代的一些思考\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-12-23T00:00:00.000Z\\",\\"dateModified\\":\\"2026-01-11T15:56:45.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Rainbow\\",\\"url\\":\\"https://rainbow-cc.github.io/MyBlog/\\"}]}"]]},"git":{"createdTime":1768147005000,"updatedTime":1768147005000,"contributors":[{"name":"Rainbow","username":"Rainbow","email":"494738974@qq.com","commits":1,"url":"https://github.com/Rainbow"}]},"readingTime":{"minutes":3.23,"words":969},"filePathRelative":"posts/chat/some-thought.md","localizedDate":"2025年12月23日","excerpt":"\\n<p>最近我在思考一个问题：作为一个程序员，在AI的浪潮下，什么东西是值钱的，什么东西不再有用。</p>\\n<p>正如C语言出来之后，汇编技能价值就降低了，会娴熟地编写汇编语言，可能用处不大了，但是懂得原理是必要的。<br>\\n和汇编语言相比，C语言无疑是更加高效的编程语言，编译器生成的汇编代码也是完全合格的。大语言模型（LLM）在一定程度上，做了相似的事情：</p>\\n<ul>\\n<li>生成前端代码，做个网站。</li>\\n<li>独立的功能，生成一个方法或函数</li>\\n<li>指令运维指令，检查问题、安装依赖</li>\\n<li>调用MCP工具，完成更多指定操作</li>\\n<li>......</li>\\n</ul>","autoDesc":true}');export{m as comp,c as data};
